{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst RestException_1 = __importDefault(require(\"./RestException\"));\nconst utility_1 = require(\"./utility\");\nclass Version {\n  /**\n   *\n   * Base version object\n   *\n   * @param domain - twilio domain\n   * @param version - api version\n   */\n  constructor(domain, version) {\n    this._domain = domain;\n    this._version = version;\n  }\n  get domain() {\n    return this._domain;\n  }\n  /**\n   * Generate absolute url from a uri\n   *\n   * @param uri - uri to transform\n   * @returns transformed url\n   */\n  absoluteUrl(uri) {\n    return this._domain.absoluteUrl(this.relativeUrl(uri));\n  }\n  /**\n   * Generate relative url from a uri\n   *\n   * @param uri - uri to transform\n   * @returns transformed url\n   */\n  relativeUrl(uri) {\n    var result = \"\";\n    if (typeof this._version === \"string\") {\n      const version = (0, utility_1.trim)(this._version, \"/\");\n      result += version;\n      result += \"/\";\n    }\n    if (typeof uri === \"string\") {\n      uri = (0, utility_1.trim)(uri, \"/\");\n      if (result === \"\") {\n        result += \"/\";\n      }\n      result += uri;\n    }\n    return result;\n  }\n  /**\n   * Make a request against the domain\n   *\n   * @param opts - request options\n   * @returns promise that resolves to request response\n   */\n  request(opts) {\n    return this._domain.request({\n      ...opts,\n      uri: this.relativeUrl(opts.uri || \"\")\n    });\n  }\n  /**\n   * Create a new record\n   *\n   * @param opts - request options\n   *\n   * @throws Error If response returns non 2xx or 201 status code\n   *\n   * @returns promise that resolves to created record\n   */\n  create(opts) {\n    var qResponse = this.request(opts);\n    qResponse = qResponse.then(function success(response) {\n      if (response.statusCode < 200 || response.statusCode >= 300) {\n        throw new RestException_1.default(response);\n      }\n      if (typeof response.body === \"string\") {\n        return JSON.parse(response.body);\n      }\n      return response.body;\n    });\n    return qResponse;\n  }\n  /**\n   * Fetch an instance of a record\n   *\n   * @param opts - request options\n   *\n   * @throws Error If response returns non 2xx or 3xx status code\n   *\n   * @returns promise that resolves to fetched result\n   */\n  fetch(opts) {\n    var qResponse = this.request(opts);\n    qResponse = qResponse.then(function success(response) {\n      if (response.statusCode < 200 || response.statusCode >= 400) {\n        throw new RestException_1.default(response);\n      }\n      if (typeof response.body === \"string\") {\n        return JSON.parse(response.body);\n      }\n      return response.body;\n    });\n    return qResponse;\n  }\n  /**\n   * Fetch a page of records\n   *\n   * @param opts - request options\n   * @returns promise that resolves to page of records\n   */\n  page(opts) {\n    return this.request(opts);\n  }\n  /**\n   * Update a record\n   *\n   * @param opts - request options\n   *\n   * @throws Error If response returns non 2xx status code\n   *\n   * @returns promise that resolves to updated result\n   */\n  update(opts) {\n    var qResponse = this.request(opts);\n    qResponse = qResponse.then(function success(response) {\n      if (response.statusCode < 200 || response.statusCode >= 300) {\n        throw new RestException_1.default(response);\n      }\n      if (typeof response.body === \"string\") {\n        return JSON.parse(response.body);\n      }\n      return response.body;\n    });\n    return qResponse;\n  }\n  /**\n   * Delete a record\n   *\n   * @param opts - request options\n   *\n   * @throws Error If response returns a 5xx status\n   *\n   * @returns promise that resolves to true if record was deleted\n   */\n  remove(opts) {\n    var qResponse = this.request(opts);\n    qResponse = qResponse.then(function success(response) {\n      if (response.statusCode < 200 || response.statusCode >= 300) {\n        throw new RestException_1.default(response);\n      }\n      return response.statusCode === 204;\n    });\n    return qResponse;\n  }\n  /**\n   * Process limits for list requests\n   *\n   * @param opts.limit - The maximum number of items to fetch\n   * @param opts.pageSize - The maximum number of items to return with every request\n   *\n   */\n  readLimits(opts) {\n    var limit = opts.limit;\n    var pageSize = opts.pageSize;\n    if (limit && !Number.isFinite(limit) || limit <= 0) {\n      throw new TypeError(\"Parameter limit must be a positive integer\");\n    }\n    if (pageSize && (!Number.isFinite(pageSize) || pageSize <= 0)) {\n      throw new TypeError(\"Parameter pageSize must be a positive integer\");\n    }\n    if (limit && !pageSize) {\n      pageSize = limit;\n    }\n    return {\n      limit: limit,\n      pageSize: pageSize\n    };\n  }\n  setPromiseCallback(operationPromise, callback) {\n    if (typeof callback === \"function\") {\n      operationPromise = operationPromise.then(value => callback(null, value)).catch(error => callback(error));\n    }\n    return operationPromise;\n  }\n  /**\n   * For each record instance, executes a provided callback function with that\n   * instance\n   *\n   * @param params - Parameters (Optional)\n   * @param params.limit - Optional maximum number of record instances to\n   *  fetch\n   * @param params.pageSize - Optional maximum number of records to return\n   *  with every request\n   * @param params.callback - Callback function to call with each\n   *  record instance\n   * @param params.done - Optional done function to call when all\n   *  records are processed, the limit is reached, or an error occurs.\n   *  Receives an error argument if an error occurs.\n   * @param callback - Callback function to call with each record.\n   *  Receives a done function argument that will short-circuit the for-each\n   *  loop that may accept an error argument.\n   * @returns Returns a promise that resolves when all records\n   *  processed or if the limit is reached, and rejects with an error if an\n   *  error occurs and is not handled in the user provided done function.\n   */\n  each(params, callback) {\n    if (typeof params === \"function\") {\n      callback = params;\n      params = {};\n    } else {\n      params = params || {};\n    }\n    if (params.callback) {\n      callback = params.callback;\n    }\n    if (typeof callback === \"undefined\") {\n      throw new Error(\"Callback function must be provided\");\n    }\n    let done = false;\n    let doneCalled = false;\n    let currentPage = 1;\n    let currentResource = 0;\n    let limits = {};\n    let pPending = true;\n    let pResolve;\n    let pReject;\n    if (this._version instanceof Version) {\n      limits = this._version.readLimits({\n        limit: params.limit,\n        pageSize: params.pageSize\n      });\n    }\n    function onComplete(error) {\n      let unhandledError = error;\n      done = true;\n      if (typeof params.done === \"function\" && !doneCalled) {\n        try {\n          params.done(unhandledError);\n          unhandledError = null;\n        } catch (e) {\n          unhandledError = e;\n        }\n      }\n      doneCalled = true;\n      if (pPending) {\n        if (unhandledError) {\n          pReject(unhandledError);\n        } else {\n          pResolve();\n        }\n        pPending = false;\n      }\n    }\n    function fetchNextPage(fn) {\n      let promise = fn();\n      if (typeof promise === \"undefined\") {\n        onComplete();\n        return;\n      }\n      promise.then(page => {\n        try {\n          page.instances.forEach(function (instance) {\n            if (done || typeof params.limit !== \"undefined\" && currentResource >= params.limit) {\n              done = true;\n              return false;\n            }\n            currentResource++;\n            callback?.(instance, onComplete);\n          });\n        } catch (e) {\n          return onComplete(e);\n        }\n        if (!done) {\n          currentPage++;\n          fetchNextPage(page.nextPage.bind(page));\n        } else {\n          onComplete();\n        }\n      });\n      promise.catch(onComplete);\n    }\n    return new Promise((resolve, reject) => {\n      pResolve = resolve;\n      pReject = reject;\n      fetchNextPage(this.page.bind(this, Object.assign(params, limits)));\n    });\n  }\n  list(params, callback) {\n    if (typeof params === \"function\") {\n      callback = params;\n      params = {};\n    } else {\n      params = params || {};\n    }\n    let allResources = [];\n    params.callback = function (resource, done) {\n      allResources.push(resource);\n      if (typeof params.limit !== \"undefined\" && allResources.length === params.limit) {\n        done();\n      }\n    };\n    let operationPromise = new Promise((resolve, reject) => {\n      params.done = function (error) {\n        if (typeof error === \"undefined\") {\n          resolve(allResources);\n        } else {\n          reject(error);\n        }\n      };\n    });\n    if (this._version instanceof Version) {\n      operationPromise = this._version.setPromiseCallback(operationPromise, callback);\n    }\n    this.each(params);\n    return operationPromise;\n  }\n}\nexports.default = Version;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","RestException_1","require","utility_1","Version","constructor","domain","version","_domain","_version","absoluteUrl","uri","relativeUrl","result","trim","request","opts","create","qResponse","then","success","response","statusCode","default","body","JSON","parse","fetch","page","update","remove","readLimits","limit","pageSize","Number","isFinite","TypeError","setPromiseCallback","operationPromise","callback","catch","error","each","params","Error","done","doneCalled","currentPage","currentResource","limits","pPending","pResolve","pReject","onComplete","unhandledError","e","fetchNextPage","fn","promise","instances","forEach","instance","nextPage","bind","Promise","resolve","reject","assign","list","allResources","resource","push","length"],"sources":["/Users/sachin/Desktop/Assignment/cpf/node_modules/twilio/lib/base/Version.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst RestException_1 = __importDefault(require(\"./RestException\"));\nconst utility_1 = require(\"./utility\");\nclass Version {\n    /**\n     *\n     * Base version object\n     *\n     * @param domain - twilio domain\n     * @param version - api version\n     */\n    constructor(domain, version) {\n        this._domain = domain;\n        this._version = version;\n    }\n    get domain() {\n        return this._domain;\n    }\n    /**\n     * Generate absolute url from a uri\n     *\n     * @param uri - uri to transform\n     * @returns transformed url\n     */\n    absoluteUrl(uri) {\n        return this._domain.absoluteUrl(this.relativeUrl(uri));\n    }\n    /**\n     * Generate relative url from a uri\n     *\n     * @param uri - uri to transform\n     * @returns transformed url\n     */\n    relativeUrl(uri) {\n        var result = \"\";\n        if (typeof this._version === \"string\") {\n            const version = (0, utility_1.trim)(this._version, \"/\");\n            result += version;\n            result += \"/\";\n        }\n        if (typeof uri === \"string\") {\n            uri = (0, utility_1.trim)(uri, \"/\");\n            if (result === \"\") {\n                result += \"/\";\n            }\n            result += uri;\n        }\n        return result;\n    }\n    /**\n     * Make a request against the domain\n     *\n     * @param opts - request options\n     * @returns promise that resolves to request response\n     */\n    request(opts) {\n        return this._domain.request({\n            ...opts,\n            uri: this.relativeUrl(opts.uri || \"\"),\n        });\n    }\n    /**\n     * Create a new record\n     *\n     * @param opts - request options\n     *\n     * @throws Error If response returns non 2xx or 201 status code\n     *\n     * @returns promise that resolves to created record\n     */\n    create(opts) {\n        var qResponse = this.request(opts);\n        qResponse = qResponse.then(function success(response) {\n            if (response.statusCode < 200 || response.statusCode >= 300) {\n                throw new RestException_1.default(response);\n            }\n            if (typeof response.body === \"string\") {\n                return JSON.parse(response.body);\n            }\n            return response.body;\n        });\n        return qResponse;\n    }\n    /**\n     * Fetch an instance of a record\n     *\n     * @param opts - request options\n     *\n     * @throws Error If response returns non 2xx or 3xx status code\n     *\n     * @returns promise that resolves to fetched result\n     */\n    fetch(opts) {\n        var qResponse = this.request(opts);\n        qResponse = qResponse.then(function success(response) {\n            if (response.statusCode < 200 || response.statusCode >= 400) {\n                throw new RestException_1.default(response);\n            }\n            if (typeof response.body === \"string\") {\n                return JSON.parse(response.body);\n            }\n            return response.body;\n        });\n        return qResponse;\n    }\n    /**\n     * Fetch a page of records\n     *\n     * @param opts - request options\n     * @returns promise that resolves to page of records\n     */\n    page(opts) {\n        return this.request(opts);\n    }\n    /**\n     * Update a record\n     *\n     * @param opts - request options\n     *\n     * @throws Error If response returns non 2xx status code\n     *\n     * @returns promise that resolves to updated result\n     */\n    update(opts) {\n        var qResponse = this.request(opts);\n        qResponse = qResponse.then(function success(response) {\n            if (response.statusCode < 200 || response.statusCode >= 300) {\n                throw new RestException_1.default(response);\n            }\n            if (typeof response.body === \"string\") {\n                return JSON.parse(response.body);\n            }\n            return response.body;\n        });\n        return qResponse;\n    }\n    /**\n     * Delete a record\n     *\n     * @param opts - request options\n     *\n     * @throws Error If response returns a 5xx status\n     *\n     * @returns promise that resolves to true if record was deleted\n     */\n    remove(opts) {\n        var qResponse = this.request(opts);\n        qResponse = qResponse.then(function success(response) {\n            if (response.statusCode < 200 || response.statusCode >= 300) {\n                throw new RestException_1.default(response);\n            }\n            return response.statusCode === 204;\n        });\n        return qResponse;\n    }\n    /**\n     * Process limits for list requests\n     *\n     * @param opts.limit - The maximum number of items to fetch\n     * @param opts.pageSize - The maximum number of items to return with every request\n     *\n     */\n    readLimits(opts) {\n        var limit = opts.limit;\n        var pageSize = opts.pageSize;\n        if ((limit && !Number.isFinite(limit)) || limit <= 0) {\n            throw new TypeError(\"Parameter limit must be a positive integer\");\n        }\n        if (pageSize && (!Number.isFinite(pageSize) || pageSize <= 0)) {\n            throw new TypeError(\"Parameter pageSize must be a positive integer\");\n        }\n        if (limit && !pageSize) {\n            pageSize = limit;\n        }\n        return {\n            limit: limit,\n            pageSize: pageSize,\n        };\n    }\n    setPromiseCallback(operationPromise, callback) {\n        if (typeof callback === \"function\") {\n            operationPromise = operationPromise\n                .then((value) => callback(null, value))\n                .catch((error) => callback(error));\n        }\n        return operationPromise;\n    }\n    /**\n     * For each record instance, executes a provided callback function with that\n     * instance\n     *\n     * @param params - Parameters (Optional)\n     * @param params.limit - Optional maximum number of record instances to\n     *  fetch\n     * @param params.pageSize - Optional maximum number of records to return\n     *  with every request\n     * @param params.callback - Callback function to call with each\n     *  record instance\n     * @param params.done - Optional done function to call when all\n     *  records are processed, the limit is reached, or an error occurs.\n     *  Receives an error argument if an error occurs.\n     * @param callback - Callback function to call with each record.\n     *  Receives a done function argument that will short-circuit the for-each\n     *  loop that may accept an error argument.\n     * @returns Returns a promise that resolves when all records\n     *  processed or if the limit is reached, and rejects with an error if an\n     *  error occurs and is not handled in the user provided done function.\n     */\n    each(params, callback) {\n        if (typeof params === \"function\") {\n            callback = params;\n            params = {};\n        }\n        else {\n            params = params || {};\n        }\n        if (params.callback) {\n            callback = params.callback;\n        }\n        if (typeof callback === \"undefined\") {\n            throw new Error(\"Callback function must be provided\");\n        }\n        let done = false;\n        let doneCalled = false;\n        let currentPage = 1;\n        let currentResource = 0;\n        let limits = {};\n        let pPending = true;\n        let pResolve;\n        let pReject;\n        if (this._version instanceof Version) {\n            limits = this._version.readLimits({\n                limit: params.limit,\n                pageSize: params.pageSize,\n            });\n        }\n        function onComplete(error) {\n            let unhandledError = error;\n            done = true;\n            if (typeof params.done === \"function\" && !doneCalled) {\n                try {\n                    params.done(unhandledError);\n                    unhandledError = null;\n                }\n                catch (e) {\n                    unhandledError = e;\n                }\n            }\n            doneCalled = true;\n            if (pPending) {\n                if (unhandledError) {\n                    pReject(unhandledError);\n                }\n                else {\n                    pResolve();\n                }\n                pPending = false;\n            }\n        }\n        function fetchNextPage(fn) {\n            let promise = fn();\n            if (typeof promise === \"undefined\") {\n                onComplete();\n                return;\n            }\n            promise.then((page) => {\n                try {\n                    page.instances.forEach(function (instance) {\n                        if (done ||\n                            (typeof params.limit !== \"undefined\" &&\n                                currentResource >= params.limit)) {\n                            done = true;\n                            return false;\n                        }\n                        currentResource++;\n                        callback?.(instance, onComplete);\n                    });\n                }\n                catch (e) {\n                    return onComplete(e);\n                }\n                if (!done) {\n                    currentPage++;\n                    fetchNextPage(page.nextPage.bind(page));\n                }\n                else {\n                    onComplete();\n                }\n            });\n            promise.catch(onComplete);\n        }\n        return new Promise((resolve, reject) => {\n            pResolve = resolve;\n            pReject = reject;\n            fetchNextPage(this.page.bind(this, Object.assign(params, limits)));\n        });\n    }\n    list(params, callback) {\n        if (typeof params === \"function\") {\n            callback = params;\n            params = {};\n        }\n        else {\n            params = params || {};\n        }\n        let allResources = [];\n        params.callback = function (resource, done) {\n            allResources.push(resource);\n            if (typeof params.limit !== \"undefined\" &&\n                allResources.length === params.limit) {\n                done();\n            }\n        };\n        let operationPromise = new Promise((resolve, reject) => {\n            params.done = function (error) {\n                if (typeof error === \"undefined\") {\n                    resolve(allResources);\n                }\n                else {\n                    reject(error);\n                }\n            };\n        });\n        if (this._version instanceof Version) {\n            operationPromise = this._version.setPromiseCallback(operationPromise, callback);\n        }\n        this.each(params);\n        return operationPromise;\n    }\n}\nexports.default = Version;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,MAAMC,eAAe,GAAGP,eAAe,CAACQ,OAAO,CAAC,iBAAiB,CAAC,CAAC;AACnE,MAAMC,SAAS,GAAGD,OAAO,CAAC,WAAW,CAAC;AACtC,MAAME,OAAO,CAAC;EACV;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,WAAWA,CAACC,MAAM,EAAEC,OAAO,EAAE;IACzB,IAAI,CAACC,OAAO,GAAGF,MAAM;IACrB,IAAI,CAACG,QAAQ,GAAGF,OAAO;EAC3B;EACA,IAAID,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAACE,OAAO;EACvB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIE,WAAWA,CAACC,GAAG,EAAE;IACb,OAAO,IAAI,CAACH,OAAO,CAACE,WAAW,CAAC,IAAI,CAACE,WAAW,CAACD,GAAG,CAAC,CAAC;EAC1D;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,WAAWA,CAACD,GAAG,EAAE;IACb,IAAIE,MAAM,GAAG,EAAE;IACf,IAAI,OAAO,IAAI,CAACJ,QAAQ,KAAK,QAAQ,EAAE;MACnC,MAAMF,OAAO,GAAG,CAAC,CAAC,EAAEJ,SAAS,CAACW,IAAI,EAAE,IAAI,CAACL,QAAQ,EAAE,GAAG,CAAC;MACvDI,MAAM,IAAIN,OAAO;MACjBM,MAAM,IAAI,GAAG;IACjB;IACA,IAAI,OAAOF,GAAG,KAAK,QAAQ,EAAE;MACzBA,GAAG,GAAG,CAAC,CAAC,EAAER,SAAS,CAACW,IAAI,EAAEH,GAAG,EAAE,GAAG,CAAC;MACnC,IAAIE,MAAM,KAAK,EAAE,EAAE;QACfA,MAAM,IAAI,GAAG;MACjB;MACAA,MAAM,IAAIF,GAAG;IACjB;IACA,OAAOE,MAAM;EACjB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIE,OAAOA,CAACC,IAAI,EAAE;IACV,OAAO,IAAI,CAACR,OAAO,CAACO,OAAO,CAAC;MACxB,GAAGC,IAAI;MACPL,GAAG,EAAE,IAAI,CAACC,WAAW,CAACI,IAAI,CAACL,GAAG,IAAI,EAAE;IACxC,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIM,MAAMA,CAACD,IAAI,EAAE;IACT,IAAIE,SAAS,GAAG,IAAI,CAACH,OAAO,CAACC,IAAI,CAAC;IAClCE,SAAS,GAAGA,SAAS,CAACC,IAAI,CAAC,SAASC,OAAOA,CAACC,QAAQ,EAAE;MAClD,IAAIA,QAAQ,CAACC,UAAU,GAAG,GAAG,IAAID,QAAQ,CAACC,UAAU,IAAI,GAAG,EAAE;QACzD,MAAM,IAAIrB,eAAe,CAACsB,OAAO,CAACF,QAAQ,CAAC;MAC/C;MACA,IAAI,OAAOA,QAAQ,CAACG,IAAI,KAAK,QAAQ,EAAE;QACnC,OAAOC,IAAI,CAACC,KAAK,CAACL,QAAQ,CAACG,IAAI,CAAC;MACpC;MACA,OAAOH,QAAQ,CAACG,IAAI;IACxB,CAAC,CAAC;IACF,OAAON,SAAS;EACpB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIS,KAAKA,CAACX,IAAI,EAAE;IACR,IAAIE,SAAS,GAAG,IAAI,CAACH,OAAO,CAACC,IAAI,CAAC;IAClCE,SAAS,GAAGA,SAAS,CAACC,IAAI,CAAC,SAASC,OAAOA,CAACC,QAAQ,EAAE;MAClD,IAAIA,QAAQ,CAACC,UAAU,GAAG,GAAG,IAAID,QAAQ,CAACC,UAAU,IAAI,GAAG,EAAE;QACzD,MAAM,IAAIrB,eAAe,CAACsB,OAAO,CAACF,QAAQ,CAAC;MAC/C;MACA,IAAI,OAAOA,QAAQ,CAACG,IAAI,KAAK,QAAQ,EAAE;QACnC,OAAOC,IAAI,CAACC,KAAK,CAACL,QAAQ,CAACG,IAAI,CAAC;MACpC;MACA,OAAOH,QAAQ,CAACG,IAAI;IACxB,CAAC,CAAC;IACF,OAAON,SAAS;EACpB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIU,IAAIA,CAACZ,IAAI,EAAE;IACP,OAAO,IAAI,CAACD,OAAO,CAACC,IAAI,CAAC;EAC7B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIa,MAAMA,CAACb,IAAI,EAAE;IACT,IAAIE,SAAS,GAAG,IAAI,CAACH,OAAO,CAACC,IAAI,CAAC;IAClCE,SAAS,GAAGA,SAAS,CAACC,IAAI,CAAC,SAASC,OAAOA,CAACC,QAAQ,EAAE;MAClD,IAAIA,QAAQ,CAACC,UAAU,GAAG,GAAG,IAAID,QAAQ,CAACC,UAAU,IAAI,GAAG,EAAE;QACzD,MAAM,IAAIrB,eAAe,CAACsB,OAAO,CAACF,QAAQ,CAAC;MAC/C;MACA,IAAI,OAAOA,QAAQ,CAACG,IAAI,KAAK,QAAQ,EAAE;QACnC,OAAOC,IAAI,CAACC,KAAK,CAACL,QAAQ,CAACG,IAAI,CAAC;MACpC;MACA,OAAOH,QAAQ,CAACG,IAAI;IACxB,CAAC,CAAC;IACF,OAAON,SAAS;EACpB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIY,MAAMA,CAACd,IAAI,EAAE;IACT,IAAIE,SAAS,GAAG,IAAI,CAACH,OAAO,CAACC,IAAI,CAAC;IAClCE,SAAS,GAAGA,SAAS,CAACC,IAAI,CAAC,SAASC,OAAOA,CAACC,QAAQ,EAAE;MAClD,IAAIA,QAAQ,CAACC,UAAU,GAAG,GAAG,IAAID,QAAQ,CAACC,UAAU,IAAI,GAAG,EAAE;QACzD,MAAM,IAAIrB,eAAe,CAACsB,OAAO,CAACF,QAAQ,CAAC;MAC/C;MACA,OAAOA,QAAQ,CAACC,UAAU,KAAK,GAAG;IACtC,CAAC,CAAC;IACF,OAAOJ,SAAS;EACpB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIa,UAAUA,CAACf,IAAI,EAAE;IACb,IAAIgB,KAAK,GAAGhB,IAAI,CAACgB,KAAK;IACtB,IAAIC,QAAQ,GAAGjB,IAAI,CAACiB,QAAQ;IAC5B,IAAKD,KAAK,IAAI,CAACE,MAAM,CAACC,QAAQ,CAACH,KAAK,CAAC,IAAKA,KAAK,IAAI,CAAC,EAAE;MAClD,MAAM,IAAII,SAAS,CAAC,4CAA4C,CAAC;IACrE;IACA,IAAIH,QAAQ,KAAK,CAACC,MAAM,CAACC,QAAQ,CAACF,QAAQ,CAAC,IAAIA,QAAQ,IAAI,CAAC,CAAC,EAAE;MAC3D,MAAM,IAAIG,SAAS,CAAC,+CAA+C,CAAC;IACxE;IACA,IAAIJ,KAAK,IAAI,CAACC,QAAQ,EAAE;MACpBA,QAAQ,GAAGD,KAAK;IACpB;IACA,OAAO;MACHA,KAAK,EAAEA,KAAK;MACZC,QAAQ,EAAEA;IACd,CAAC;EACL;EACAI,kBAAkBA,CAACC,gBAAgB,EAAEC,QAAQ,EAAE;IAC3C,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;MAChCD,gBAAgB,GAAGA,gBAAgB,CAC9BnB,IAAI,CAAEnB,KAAK,IAAKuC,QAAQ,CAAC,IAAI,EAAEvC,KAAK,CAAC,CAAC,CACtCwC,KAAK,CAAEC,KAAK,IAAKF,QAAQ,CAACE,KAAK,CAAC,CAAC;IAC1C;IACA,OAAOH,gBAAgB;EAC3B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACII,IAAIA,CAACC,MAAM,EAAEJ,QAAQ,EAAE;IACnB,IAAI,OAAOI,MAAM,KAAK,UAAU,EAAE;MAC9BJ,QAAQ,GAAGI,MAAM;MACjBA,MAAM,GAAG,CAAC,CAAC;IACf,CAAC,MACI;MACDA,MAAM,GAAGA,MAAM,IAAI,CAAC,CAAC;IACzB;IACA,IAAIA,MAAM,CAACJ,QAAQ,EAAE;MACjBA,QAAQ,GAAGI,MAAM,CAACJ,QAAQ;IAC9B;IACA,IAAI,OAAOA,QAAQ,KAAK,WAAW,EAAE;MACjC,MAAM,IAAIK,KAAK,CAAC,oCAAoC,CAAC;IACzD;IACA,IAAIC,IAAI,GAAG,KAAK;IAChB,IAAIC,UAAU,GAAG,KAAK;IACtB,IAAIC,WAAW,GAAG,CAAC;IACnB,IAAIC,eAAe,GAAG,CAAC;IACvB,IAAIC,MAAM,GAAG,CAAC,CAAC;IACf,IAAIC,QAAQ,GAAG,IAAI;IACnB,IAAIC,QAAQ;IACZ,IAAIC,OAAO;IACX,IAAI,IAAI,CAAC3C,QAAQ,YAAYL,OAAO,EAAE;MAClC6C,MAAM,GAAG,IAAI,CAACxC,QAAQ,CAACsB,UAAU,CAAC;QAC9BC,KAAK,EAAEW,MAAM,CAACX,KAAK;QACnBC,QAAQ,EAAEU,MAAM,CAACV;MACrB,CAAC,CAAC;IACN;IACA,SAASoB,UAAUA,CAACZ,KAAK,EAAE;MACvB,IAAIa,cAAc,GAAGb,KAAK;MAC1BI,IAAI,GAAG,IAAI;MACX,IAAI,OAAOF,MAAM,CAACE,IAAI,KAAK,UAAU,IAAI,CAACC,UAAU,EAAE;QAClD,IAAI;UACAH,MAAM,CAACE,IAAI,CAACS,cAAc,CAAC;UAC3BA,cAAc,GAAG,IAAI;QACzB,CAAC,CACD,OAAOC,CAAC,EAAE;UACND,cAAc,GAAGC,CAAC;QACtB;MACJ;MACAT,UAAU,GAAG,IAAI;MACjB,IAAII,QAAQ,EAAE;QACV,IAAII,cAAc,EAAE;UAChBF,OAAO,CAACE,cAAc,CAAC;QAC3B,CAAC,MACI;UACDH,QAAQ,CAAC,CAAC;QACd;QACAD,QAAQ,GAAG,KAAK;MACpB;IACJ;IACA,SAASM,aAAaA,CAACC,EAAE,EAAE;MACvB,IAAIC,OAAO,GAAGD,EAAE,CAAC,CAAC;MAClB,IAAI,OAAOC,OAAO,KAAK,WAAW,EAAE;QAChCL,UAAU,CAAC,CAAC;QACZ;MACJ;MACAK,OAAO,CAACvC,IAAI,CAAES,IAAI,IAAK;QACnB,IAAI;UACAA,IAAI,CAAC+B,SAAS,CAACC,OAAO,CAAC,UAAUC,QAAQ,EAAE;YACvC,IAAIhB,IAAI,IACH,OAAOF,MAAM,CAACX,KAAK,KAAK,WAAW,IAChCgB,eAAe,IAAIL,MAAM,CAACX,KAAM,EAAE;cACtCa,IAAI,GAAG,IAAI;cACX,OAAO,KAAK;YAChB;YACAG,eAAe,EAAE;YACjBT,QAAQ,GAAGsB,QAAQ,EAAER,UAAU,CAAC;UACpC,CAAC,CAAC;QACN,CAAC,CACD,OAAOE,CAAC,EAAE;UACN,OAAOF,UAAU,CAACE,CAAC,CAAC;QACxB;QACA,IAAI,CAACV,IAAI,EAAE;UACPE,WAAW,EAAE;UACbS,aAAa,CAAC5B,IAAI,CAACkC,QAAQ,CAACC,IAAI,CAACnC,IAAI,CAAC,CAAC;QAC3C,CAAC,MACI;UACDyB,UAAU,CAAC,CAAC;QAChB;MACJ,CAAC,CAAC;MACFK,OAAO,CAAClB,KAAK,CAACa,UAAU,CAAC;IAC7B;IACA,OAAO,IAAIW,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACpCf,QAAQ,GAAGc,OAAO;MAClBb,OAAO,GAAGc,MAAM;MAChBV,aAAa,CAAC,IAAI,CAAC5B,IAAI,CAACmC,IAAI,CAAC,IAAI,EAAElE,MAAM,CAACsE,MAAM,CAACxB,MAAM,EAAEM,MAAM,CAAC,CAAC,CAAC;IACtE,CAAC,CAAC;EACN;EACAmB,IAAIA,CAACzB,MAAM,EAAEJ,QAAQ,EAAE;IACnB,IAAI,OAAOI,MAAM,KAAK,UAAU,EAAE;MAC9BJ,QAAQ,GAAGI,MAAM;MACjBA,MAAM,GAAG,CAAC,CAAC;IACf,CAAC,MACI;MACDA,MAAM,GAAGA,MAAM,IAAI,CAAC,CAAC;IACzB;IACA,IAAI0B,YAAY,GAAG,EAAE;IACrB1B,MAAM,CAACJ,QAAQ,GAAG,UAAU+B,QAAQ,EAAEzB,IAAI,EAAE;MACxCwB,YAAY,CAACE,IAAI,CAACD,QAAQ,CAAC;MAC3B,IAAI,OAAO3B,MAAM,CAACX,KAAK,KAAK,WAAW,IACnCqC,YAAY,CAACG,MAAM,KAAK7B,MAAM,CAACX,KAAK,EAAE;QACtCa,IAAI,CAAC,CAAC;MACV;IACJ,CAAC;IACD,IAAIP,gBAAgB,GAAG,IAAI0B,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACpDvB,MAAM,CAACE,IAAI,GAAG,UAAUJ,KAAK,EAAE;QAC3B,IAAI,OAAOA,KAAK,KAAK,WAAW,EAAE;UAC9BwB,OAAO,CAACI,YAAY,CAAC;QACzB,CAAC,MACI;UACDH,MAAM,CAACzB,KAAK,CAAC;QACjB;MACJ,CAAC;IACL,CAAC,CAAC;IACF,IAAI,IAAI,CAAChC,QAAQ,YAAYL,OAAO,EAAE;MAClCkC,gBAAgB,GAAG,IAAI,CAAC7B,QAAQ,CAAC4B,kBAAkB,CAACC,gBAAgB,EAAEC,QAAQ,CAAC;IACnF;IACA,IAAI,CAACG,IAAI,CAACC,MAAM,CAAC;IACjB,OAAOL,gBAAgB;EAC3B;AACJ;AACAvC,OAAO,CAACwB,OAAO,GAAGnB,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}