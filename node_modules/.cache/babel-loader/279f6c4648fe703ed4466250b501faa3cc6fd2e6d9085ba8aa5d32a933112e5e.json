{"ast":null,"code":"'use strict';\n\nvar crypto = require('crypto');\nvar _ = require('lodash');\nvar scmp = require('scmp');\nvar urllib = require('url');\nvar Url = require('url-parse');\n\n/**\n * Utility function to construct the URL string, since Node.js url library won't include standard port numbers\n *\n * @param {Url} parsedUrl - The parsed url object that Twilio requested on your server\n * @returns {string} - URL with standard port number included\n */\nfunction buildUrlWithStandardPort(parsedUrl) {\n  let url = '';\n  const port = parsedUrl.protocol === 'https:' ? ':443' : ':80';\n  url += parsedUrl.protocol ? parsedUrl.protocol + '//' : '';\n  url += parsedUrl.username;\n  url += parsedUrl.password ? ':' + parsedUrl.password : '';\n  url += parsedUrl.username || parsedUrl.password ? '@' : '';\n  url += parsedUrl.host ? parsedUrl.host + port : '';\n  url += parsedUrl.pathname + parsedUrl.query + parsedUrl.hash;\n  return url;\n}\n\n/**\n Utility function to add a port number to a URL\n\n @param {Url} parsedUrl - The parsed url object that Twilio requested on your server\n @returns {string} - URL with port\n */\nfunction addPort(parsedUrl) {\n  if (!parsedUrl.port) {\n    return buildUrlWithStandardPort(parsedUrl);\n  }\n  return parsedUrl.toString();\n}\n\n/**\n Utility function to remove a port number from a URL\n\n @param {Url} parsedUrl - The parsed url object that Twilio requested on your server\n @returns {string} - URL without port\n */\nfunction removePort(parsedUrl) {\n  parsedUrl.set('port', '');\n  return parsedUrl.toString();\n}\n\n/**\n Utility function to get the expected signature for a given request\n\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {string} url - The full URL (with query string) you configured to handle this request\n @param {object} params - the parameters sent with this request\n @returns {string} - signature\n */\nfunction getExpectedTwilioSignature(authToken, url, params) {\n  if (url.indexOf('bodySHA256') !== -1 && params === null) {\n    params = {};\n  }\n  var data = Object.keys(params).sort().reduce((acc, key) => acc + key + params[key], url);\n  return crypto.createHmac('sha1', authToken).update(Buffer.from(data, 'utf-8')).digest('base64');\n}\n\n/**\n Utility function to get the expected body hash for a given request's body\n\n @param {string} body - The plain-text body of the request\n */\nfunction getExpectedBodyHash(body) {\n  return crypto.createHash('sha256').update(Buffer.from(body, 'utf-8')).digest('hex');\n}\n\n/**\n Utility function to validate an incoming request is indeed from Twilio\n\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {string} twilioHeader - The value of the X-Twilio-Signature header from the request\n @param {string} url - The full URL (with query string) you configured to handle this request\n @param {object} params - the parameters sent with this request\n @returns {boolean} - valid\n */\nfunction validateRequest(authToken, twilioHeader, url, params) {\n  twilioHeader = twilioHeader || '';\n  const urlObject = new Url(url);\n  const urlWithPort = addPort(urlObject);\n  const urlWithoutPort = removePort(urlObject);\n\n  /*\n   *  Check signature of the url with and without the port number\n   *  since signature generation on the back end is inconsistent\n   */\n  const signatureWithPort = getExpectedTwilioSignature(authToken, urlWithPort, params);\n  const signatureWithoutPort = getExpectedTwilioSignature(authToken, urlWithoutPort, params);\n  const validSignatureWithPort = scmp(Buffer.from(twilioHeader), Buffer.from(signatureWithPort));\n  const validSignatureWithoutPort = scmp(Buffer.from(twilioHeader), Buffer.from(signatureWithoutPort));\n  return validSignatureWithoutPort || validSignatureWithPort;\n}\nfunction validateBody(body, bodyHash) {\n  var expectedHash = getExpectedBodyHash(body);\n  return scmp(Buffer.from(bodyHash), Buffer.from(expectedHash));\n}\n\n/**\n Utility function to validate an incoming request is indeed from Twilio. This also validates\n the request body against the bodySHA256 post parameter.\n\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {string} twilioHeader - The value of the X-Twilio-Signature header from the request\n @param {string} url - The full URL (with query string) you configured to handle this request\n @param {string} body - The body of the request\n @returns {boolean} - valid\n */\nfunction validateRequestWithBody(authToken, twilioHeader, url, body) {\n  const urlObject = new Url(url, true);\n  return validateRequest(authToken, twilioHeader, url, {}) && validateBody(body, urlObject.query.bodySHA256);\n}\n\n/**\n Utility function to validate an incoming request is indeed from Twilio (for use with express).\n adapted from https://github.com/crabasa/twiliosig\n\n @param {object} request - An expressjs request object (http://expressjs.com/api.html#req.params)\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {object} opts - options for request validation:\n    - url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n    - host: manually specify the host name used by Twilio in a number's webhook config\n    - protocol: manually specify the protocol used by Twilio in a number's webhook config\n */\nfunction validateExpressRequest(request, authToken, opts) {\n  var options = opts || {};\n  var webhookUrl;\n  if (options.url) {\n    // Let the user specify the full URL\n    webhookUrl = options.url;\n  } else {\n    // Use configured host/protocol, or infer based on request\n    var protocol = options.protocol || request.protocol;\n    var host = options.host || request.headers.host;\n    webhookUrl = urllib.format({\n      protocol: protocol,\n      host: host,\n      pathname: request.originalUrl\n    });\n    if (request.originalUrl.search(/\\?/) >= 0) {\n      webhookUrl = webhookUrl.replace(/%3F/g, '?');\n    }\n  }\n  if (webhookUrl.indexOf('bodySHA256') > 0) {\n    return validateRequestWithBody(authToken, request.header('X-Twilio-Signature'), webhookUrl, request.rawBody || '{}');\n  } else {\n    return validateRequest(authToken, request.header('X-Twilio-Signature'), webhookUrl, request.body || {});\n  }\n}\n\n/**\nExpress middleware to accompany a Twilio webhook. Provides Twilio\nrequest validation, and makes the response a little more friendly for our\nTwiML generator.  Request validation requires the express.urlencoded middleware\nto have been applied (e.g. app.use(express.urlencoded()); in your app config).\n\nOptions:\n- validate: {Boolean} whether or not the middleware should validate the request\n    came from Twilio.  Default true. If the request does not originate from\n    Twilio, we will return a text body and a 403.  If there is no configured\n    auth token and validate=true, this is an error condition, so we will return\n    a 500.\n- host: manually specify the host name used by Twilio in a number's webhook config\n- protocol: manually specify the protocol used by Twilio in a number's webhook config\n- url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n\nReturns a middleware function.\n\nExamples:\nvar webhookMiddleware = twilio.webhook();\nvar webhookMiddleware = twilio.webhook('asdha9dhjasd'); //init with auth token\nvar webhookMiddleware = twilio.webhook({\n    validate:false // don't attempt request validation\n});\nvar webhookMiddleware = twilio.webhook({\n    host: 'hook.twilio.com',\n    protocol: 'https'\n});\n */\nfunction webhook() {\n  var opts = {\n    validate: true\n  };\n\n  // Process arguments\n  var tokenString;\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    var arg = arguments[i];\n    if (typeof arg === 'string') {\n      tokenString = arg;\n    } else {\n      opts = _.extend(opts, arg);\n    }\n  }\n\n  // set auth token from input or environment variable\n  opts.authToken = tokenString ? tokenString : process.env.TWILIO_AUTH_TOKEN;\n\n  // Create middleware function\n  return function hook(request, response, next) {\n    // Do validation if requested\n    if (opts.validate) {\n      // Check if the 'X-Twilio-Signature' header exists or not\n      if (!request.header('X-Twilio-Signature')) {\n        return response.type('text/plain').status(400).send('No signature header error - X-Twilio-Signature header does not exist, maybe this request is not coming from Twilio.');\n      }\n      // Check for a valid auth token\n      if (!opts.authToken) {\n        console.error('[Twilio]: Error - Twilio auth token is required for webhook request validation.');\n        response.type('text/plain').status(500).send('Webhook Error - we attempted to validate this request without first configuring our auth token.');\n      } else {\n        // Check that the request originated from Twilio\n        var valid = validateExpressRequest(request, opts.authToken, {\n          url: opts.url,\n          host: opts.host,\n          protocol: opts.protocol\n        });\n        if (valid) {\n          next();\n        } else {\n          return response.type('text/plain').status(403).send('Twilio Request Validation Failed.');\n        }\n      }\n    } else {\n      next();\n    }\n  };\n}\nmodule.exports = {\n  getExpectedTwilioSignature,\n  getExpectedBodyHash,\n  validateRequest,\n  validateRequestWithBody,\n  validateExpressRequest,\n  validateBody,\n  webhook\n};","map":{"version":3,"names":["crypto","require","_","scmp","urllib","Url","buildUrlWithStandardPort","parsedUrl","url","port","protocol","username","password","host","pathname","query","hash","addPort","toString","removePort","set","getExpectedTwilioSignature","authToken","params","indexOf","data","Object","keys","sort","reduce","acc","key","createHmac","update","Buffer","from","digest","getExpectedBodyHash","body","createHash","validateRequest","twilioHeader","urlObject","urlWithPort","urlWithoutPort","signatureWithPort","signatureWithoutPort","validSignatureWithPort","validSignatureWithoutPort","validateBody","bodyHash","expectedHash","validateRequestWithBody","bodySHA256","validateExpressRequest","request","opts","options","webhookUrl","headers","format","originalUrl","search","replace","header","rawBody","webhook","validate","tokenString","i","l","arguments","length","arg","extend","process","env","TWILIO_AUTH_TOKEN","hook","response","next","type","status","send","console","error","valid","module","exports"],"sources":["/Users/sachin/Desktop/Assignment/cpf/node_modules/twilio/lib/webhooks/webhooks.js"],"sourcesContent":["'use strict';\n\nvar crypto = require('crypto');\nvar _ = require('lodash');\nvar scmp = require('scmp');\nvar urllib = require('url');\nvar Url = require('url-parse');\n\n/**\n * Utility function to construct the URL string, since Node.js url library won't include standard port numbers\n *\n * @param {Url} parsedUrl - The parsed url object that Twilio requested on your server\n * @returns {string} - URL with standard port number included\n */\nfunction buildUrlWithStandardPort(parsedUrl) {\n  let url = '';\n  const port = parsedUrl.protocol === 'https:' ? ':443' : ':80';\n\n  url += parsedUrl.protocol ? parsedUrl.protocol + '//' : '';\n  url += parsedUrl.username;\n  url += parsedUrl.password ? ':' + parsedUrl.password : '';\n  url += (parsedUrl.username || parsedUrl.password) ? '@' : '';\n  url += parsedUrl.host ? parsedUrl.host + port : '';\n  url += parsedUrl.pathname + parsedUrl.query + parsedUrl.hash;\n\n  return url;\n}\n\n/**\n Utility function to add a port number to a URL\n\n @param {Url} parsedUrl - The parsed url object that Twilio requested on your server\n @returns {string} - URL with port\n */\nfunction addPort(parsedUrl) {\n  if (!parsedUrl.port) {\n    return buildUrlWithStandardPort(parsedUrl);\n  }\n  return parsedUrl.toString();\n}\n\n/**\n Utility function to remove a port number from a URL\n\n @param {Url} parsedUrl - The parsed url object that Twilio requested on your server\n @returns {string} - URL without port\n */\nfunction removePort(parsedUrl) {\n  parsedUrl.set('port', '');\n  return parsedUrl.toString();\n}\n\n/**\n Utility function to get the expected signature for a given request\n\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {string} url - The full URL (with query string) you configured to handle this request\n @param {object} params - the parameters sent with this request\n @returns {string} - signature\n */\nfunction getExpectedTwilioSignature(authToken, url, params) {\n  if (url.indexOf('bodySHA256') !== -1 && params === null) {\n    params = {};\n  }\n\n  var data = Object.keys(params)\n    .sort()\n    .reduce((acc, key) => acc + key + params[key], url);\n\n  return crypto\n    .createHmac('sha1', authToken)\n    .update(Buffer.from(data, 'utf-8'))\n    .digest('base64');\n}\n\n/**\n Utility function to get the expected body hash for a given request's body\n\n @param {string} body - The plain-text body of the request\n */\nfunction getExpectedBodyHash(body) {\n  return crypto\n    .createHash('sha256')\n    .update(Buffer.from(body, 'utf-8'))\n    .digest('hex');\n}\n\n/**\n Utility function to validate an incoming request is indeed from Twilio\n\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {string} twilioHeader - The value of the X-Twilio-Signature header from the request\n @param {string} url - The full URL (with query string) you configured to handle this request\n @param {object} params - the parameters sent with this request\n @returns {boolean} - valid\n */\nfunction validateRequest(authToken, twilioHeader, url, params) {\n  twilioHeader = twilioHeader || '';\n  const urlObject = new Url(url);\n  const urlWithPort = addPort(urlObject);\n  const urlWithoutPort = removePort(urlObject);\n\n  /*\n   *  Check signature of the url with and without the port number\n   *  since signature generation on the back end is inconsistent\n   */\n  const signatureWithPort = getExpectedTwilioSignature(authToken, urlWithPort, params);\n  const signatureWithoutPort = getExpectedTwilioSignature(authToken, urlWithoutPort, params);\n  const validSignatureWithPort = scmp(Buffer.from(twilioHeader), Buffer.from(signatureWithPort));\n  const validSignatureWithoutPort = scmp(Buffer.from(twilioHeader), Buffer.from(signatureWithoutPort));\n\n  return validSignatureWithoutPort || validSignatureWithPort;\n}\n\nfunction validateBody(body, bodyHash) {\n  var expectedHash = getExpectedBodyHash(body);\n  return scmp(Buffer.from(bodyHash), Buffer.from(expectedHash));\n}\n\n/**\n Utility function to validate an incoming request is indeed from Twilio. This also validates\n the request body against the bodySHA256 post parameter.\n\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {string} twilioHeader - The value of the X-Twilio-Signature header from the request\n @param {string} url - The full URL (with query string) you configured to handle this request\n @param {string} body - The body of the request\n @returns {boolean} - valid\n */\nfunction validateRequestWithBody(authToken, twilioHeader, url, body) {\n  const urlObject = new Url(url, true);\n  return validateRequest(authToken, twilioHeader, url, {}) &&\n    validateBody(body, urlObject.query.bodySHA256);\n}\n\n/**\n Utility function to validate an incoming request is indeed from Twilio (for use with express).\n adapted from https://github.com/crabasa/twiliosig\n\n @param {object} request - An expressjs request object (http://expressjs.com/api.html#req.params)\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {object} opts - options for request validation:\n    - url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n    - host: manually specify the host name used by Twilio in a number's webhook config\n    - protocol: manually specify the protocol used by Twilio in a number's webhook config\n */\nfunction validateExpressRequest(request, authToken, opts) {\n  var options = opts || {};\n  var webhookUrl;\n\n  if (options.url) {\n    // Let the user specify the full URL\n    webhookUrl = options.url;\n  } else {\n    // Use configured host/protocol, or infer based on request\n    var protocol = options.protocol || request.protocol;\n    var host = options.host || request.headers.host;\n\n    webhookUrl = urllib.format({\n      protocol: protocol,\n      host: host,\n      pathname: request.originalUrl,\n    });\n    if (request.originalUrl.search(/\\?/) >= 0) {\n      webhookUrl = webhookUrl.replace(/%3F/g, '?');\n    }\n\n  }\n\n  if (webhookUrl.indexOf('bodySHA256') > 0) {\n    return validateRequestWithBody(\n      authToken,\n      request.header('X-Twilio-Signature'),\n      webhookUrl,\n      request.rawBody || '{}'\n    );\n  } else {\n    return validateRequest(\n      authToken,\n      request.header('X-Twilio-Signature'),\n      webhookUrl,\n      request.body || {}\n    );\n  }\n}\n\n/**\nExpress middleware to accompany a Twilio webhook. Provides Twilio\nrequest validation, and makes the response a little more friendly for our\nTwiML generator.  Request validation requires the express.urlencoded middleware\nto have been applied (e.g. app.use(express.urlencoded()); in your app config).\n\nOptions:\n- validate: {Boolean} whether or not the middleware should validate the request\n    came from Twilio.  Default true. If the request does not originate from\n    Twilio, we will return a text body and a 403.  If there is no configured\n    auth token and validate=true, this is an error condition, so we will return\n    a 500.\n- host: manually specify the host name used by Twilio in a number's webhook config\n- protocol: manually specify the protocol used by Twilio in a number's webhook config\n- url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n\nReturns a middleware function.\n\nExamples:\nvar webhookMiddleware = twilio.webhook();\nvar webhookMiddleware = twilio.webhook('asdha9dhjasd'); //init with auth token\nvar webhookMiddleware = twilio.webhook({\n    validate:false // don't attempt request validation\n});\nvar webhookMiddleware = twilio.webhook({\n    host: 'hook.twilio.com',\n    protocol: 'https'\n});\n */\nfunction webhook() {\n  var opts = {\n    validate: true,\n  };\n\n  // Process arguments\n  var tokenString;\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    var arg = arguments[i];\n    if (typeof arg === 'string') {\n      tokenString = arg;\n    } else {\n      opts = _.extend(opts, arg);\n    }\n  }\n\n  // set auth token from input or environment variable\n  opts.authToken = tokenString ? tokenString : process.env.TWILIO_AUTH_TOKEN;\n\n  // Create middleware function\n  return function hook(request, response, next) {\n    // Do validation if requested\n    if (opts.validate) {\n      // Check if the 'X-Twilio-Signature' header exists or not\n      if (!request.header('X-Twilio-Signature')) {\n        return response.type('text/plain')\n          .status(400)\n          .send('No signature header error - X-Twilio-Signature header does not exist, maybe this request is not coming from Twilio.');\n      }\n      // Check for a valid auth token\n      if (!opts.authToken) {\n        console.error('[Twilio]: Error - Twilio auth token is required for webhook request validation.');\n        response.type('text/plain')\n          .status(500)\n          .send('Webhook Error - we attempted to validate this request without first configuring our auth token.');\n      } else {\n        // Check that the request originated from Twilio\n        var valid = validateExpressRequest(request, opts.authToken, {\n          url: opts.url,\n          host: opts.host,\n          protocol: opts.protocol,\n        });\n\n        if (valid) {\n          next();\n        } else {\n          return response\n            .type('text/plain')\n            .status(403)\n            .send('Twilio Request Validation Failed.');\n        }\n      }\n    } else {\n      next();\n    }\n  };\n}\n\nmodule.exports = {\n  getExpectedTwilioSignature,\n  getExpectedBodyHash,\n  validateRequest,\n  validateRequestWithBody,\n  validateExpressRequest,\n  validateBody,\n  webhook,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}