{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.webhook = exports.validateExpressRequest = exports.validateIncomingRequest = exports.validateRequestWithBody = exports.validateBody = exports.validateRequest = exports.getExpectedBodyHash = exports.getExpectedTwilioSignature = void 0;\nconst scmp = require(\"scmp\");\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst url_1 = __importDefault(require(\"url\"));\nconst url_parse_1 = __importDefault(require(\"url-parse\"));\n/**\n * Utility function to construct the URL string, since Node.js url library won't include standard port numbers\n *\n * @param parsedUrl - The parsed url object that Twilio requested on your server\n * @returns URL with standard port number included\n */\nfunction buildUrlWithStandardPort(parsedUrl) {\n  let url = \"\";\n  const port = parsedUrl.protocol === \"https:\" ? \":443\" : \":80\";\n  url += parsedUrl.protocol ? parsedUrl.protocol + \"//\" : \"\";\n  url += parsedUrl.username;\n  url += parsedUrl.password ? \":\" + parsedUrl.password : \"\";\n  url += parsedUrl.username || parsedUrl.password ? \"@\" : \"\";\n  url += parsedUrl.host ? parsedUrl.host + port : \"\";\n  url += parsedUrl.pathname + parsedUrl.query + parsedUrl.hash;\n  return url;\n}\n/**\n Utility function to add a port number to a URL\n\n @param parsedUrl - The parsed url object that Twilio requested on your server\n @returns URL with port\n */\nfunction addPort(parsedUrl) {\n  if (!parsedUrl.port) {\n    return buildUrlWithStandardPort(parsedUrl);\n  }\n  return parsedUrl.toString();\n}\n/**\n Utility function to remove a port number from a URL\n\n @param parsedUrl - The parsed url object that Twilio requested on your server\n @returns URL without port\n */\nfunction removePort(parsedUrl) {\n  parsedUrl.set(\"port\", \"\");\n  return parsedUrl.toString();\n}\n/**\n Utility function to convert request parameter to a string format\n\n @param paramName - The request parameter name\n @param paramValue - The request parameter value\n @returns Formatted parameter string\n */\nfunction toFormUrlEncodedParam(paramName, paramValue) {\n  if (paramValue instanceof Array) {\n    return Array.from(new Set(paramValue)).sort().map(val => toFormUrlEncodedParam(paramName, val)).reduce((acc, val) => acc + val, \"\");\n  }\n  return paramName + paramValue;\n}\n/**\n Utility function to get the expected signature for a given request\n\n @param authToken - The auth token, as seen in the Twilio portal\n @param url - The full URL (with query string) you configured to handle\n this request\n @param params - the parameters sent with this request\n @returns signature\n */\nfunction getExpectedTwilioSignature(authToken, url, params) {\n  if (url.indexOf(\"bodySHA256\") !== -1 && params === null) {\n    params = {};\n  }\n  var data = Object.keys(params).sort().reduce((acc, key) => acc + toFormUrlEncodedParam(key, params[key]), url);\n  return crypto_1.default.createHmac(\"sha1\", authToken).update(Buffer.from(data, \"utf-8\")).digest(\"base64\");\n}\nexports.getExpectedTwilioSignature = getExpectedTwilioSignature;\n/**\n Utility function to get the expected body hash for a given request's body\n\n @param body - The plain-text body of the request\n */\nfunction getExpectedBodyHash(body) {\n  return crypto_1.default.createHash(\"sha256\").update(Buffer.from(body, \"utf-8\")).digest(\"hex\");\n}\nexports.getExpectedBodyHash = getExpectedBodyHash;\n/**\n Utility function to validate an incoming request is indeed from Twilio\n\n @param authToken - The auth token, as seen in the Twilio portal\n @param twilioHeader - The value of the X-Twilio-Signature header from the request\n @param url - The full URL (with query string) you configured to handle this request\n @param params - the parameters sent with this request\n @returns valid\n */\nfunction validateRequest(authToken, twilioHeader, url, params) {\n  twilioHeader = twilioHeader || \"\";\n  const urlObject = new url_parse_1.default(url);\n  const urlWithPort = addPort(urlObject);\n  const urlWithoutPort = removePort(urlObject);\n  /*\n   *  Check signature of the url with and without the port number\n   *  since signature generation on the back end is inconsistent\n   */\n  const signatureWithPort = getExpectedTwilioSignature(authToken, urlWithPort, params);\n  const signatureWithoutPort = getExpectedTwilioSignature(authToken, urlWithoutPort, params);\n  const validSignatureWithPort = scmp(Buffer.from(twilioHeader), Buffer.from(signatureWithPort));\n  const validSignatureWithoutPort = scmp(Buffer.from(twilioHeader), Buffer.from(signatureWithoutPort));\n  return validSignatureWithoutPort || validSignatureWithPort;\n}\nexports.validateRequest = validateRequest;\nfunction validateBody(body, bodyHash) {\n  var expectedHash = getExpectedBodyHash(body);\n  return scmp(Buffer.from(bodyHash), Buffer.from(expectedHash));\n}\nexports.validateBody = validateBody;\n/**\n Utility function to validate an incoming request is indeed from Twilio. This also validates\n the request body against the bodySHA256 post parameter.\n\n @param authToken - The auth token, as seen in the Twilio portal\n @param twilioHeader - The value of the X-Twilio-Signature header from the request\n @param url - The full URL (with query string) you configured to handle this request\n @param body - The body of the request\n @returns valid\n */\nfunction validateRequestWithBody(authToken, twilioHeader, url, body) {\n  const urlObject = new url_parse_1.default(url, true);\n  return validateRequest(authToken, twilioHeader, url, {}) && validateBody(body, urlObject.query.bodySHA256 || \"\");\n}\nexports.validateRequestWithBody = validateRequestWithBody;\n/**\n Utility function to validate an incoming request is indeed from Twilio.\n adapted from https://github.com/crabasa/twiliosig\n\n @param request - A request object (based on Express implementation http://expressjs.com/api.html#req.params)\n @param authToken - The auth token, as seen in the Twilio portal\n @param opts - options for request validation:\n    -> url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n    -> host: manually specify the host name used by Twilio in a number's webhook config\n    -> protocol: manually specify the protocol used by Twilio in a number's webhook config\n */\nfunction validateIncomingRequest(request, authToken, opts) {\n  var options = opts || {};\n  var webhookUrl;\n  if (options.url) {\n    // Let the user specify the full URL\n    webhookUrl = options.url;\n  } else {\n    // Use configured host/protocol, or infer based on request\n    var protocol = options.protocol || request.protocol;\n    var host = options.host || request.headers.host;\n    webhookUrl = url_1.default.format({\n      protocol: protocol,\n      host: host,\n      pathname: request.originalUrl\n    });\n    if (request.originalUrl.search(/\\?/) >= 0) {\n      webhookUrl = webhookUrl.replace(/%3F/g, \"?\");\n    }\n  }\n  if (webhookUrl.indexOf(\"bodySHA256\") > 0) {\n    return validateRequestWithBody(authToken, request.header(\"X-Twilio-Signature\") || \"\", webhookUrl, request.rawBody || \"{}\");\n  } else {\n    return validateRequest(authToken, request.header(\"X-Twilio-Signature\") || \"\", webhookUrl, request.body || {});\n  }\n}\nexports.validateIncomingRequest = validateIncomingRequest;\nfunction validateExpressRequest(request, authToken, opts) {\n  return validateIncomingRequest(request, authToken, opts);\n}\nexports.validateExpressRequest = validateExpressRequest;\n/**\nExpress middleware to accompany a Twilio webhook. Provides Twilio\nrequest validation, and makes the response a little more friendly for our\nTwiML generator.  Request validation requires the express.urlencoded middleware\nto have been applied (e.g. app.use(express.urlencoded()); in your app config).\n\nOptions:\n- validate: {Boolean} whether or not the middleware should validate the request\n    came from Twilio.  Default true. If the request does not originate from\n    Twilio, we will return a text body and a 403.  If there is no configured\n    auth token and validate=true, this is an error condition, so we will return\n    a 500.\n- host: manually specify the host name used by Twilio in a number's webhook config\n- protocol: manually specify the protocol used by Twilio in a number's webhook config\n- url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n\nReturns a middleware function.\n\nExamples:\nvar webhookMiddleware = twilio.webhook();\nvar webhookMiddleware = twilio.webhook('asdha9dhjasd'); //init with auth token\nvar webhookMiddleware = twilio.webhook({\n    validate:false // don't attempt request validation\n});\nvar webhookMiddleware = twilio.webhook({\n    host: 'hook.twilio.com',\n    protocol: 'https'\n});\n */\nfunction webhook(opts, authToken) {\n  let token;\n  let options = undefined;\n  // Narrowing the args\n  if (opts) {\n    if (typeof opts === \"string\") {\n      token = opts;\n    }\n    if (typeof opts === \"object\") {\n      options = opts;\n    }\n  }\n  if (authToken) {\n    if (typeof authToken === \"string\") {\n      token = authToken;\n    }\n    if (typeof authToken === \"object\") {\n      options = authToken;\n    }\n  }\n  if (!options) {\n    options = {\n      validate: true\n    };\n  }\n  // Process arguments\n  var tokenString;\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    var arg = arguments[i];\n    if (typeof arg === \"string\") {\n      tokenString = arg;\n    } else {\n      options = Object.assign(options || {}, arg);\n    }\n  }\n  // set auth token from input or environment variable\n  if (options) {\n    options.authToken = tokenString ? tokenString : process.env.TWILIO_AUTH_TOKEN;\n  }\n  // Create middleware function\n  return function hook(request, response, next) {\n    // Do validation if requested\n    if (options?.validate) {\n      // Check if the 'X-Twilio-Signature' header exists or not\n      if (!request.header(\"X-Twilio-Signature\")) {\n        return response.type(\"text/plain\").status(400).send(\"No signature header error - X-Twilio-Signature header does not exist, maybe this request is not coming from Twilio.\");\n      }\n      // Check for a valid auth token\n      if (!options?.authToken) {\n        console.error(\"[Twilio]: Error - Twilio auth token is required for webhook request validation.\");\n        response.type(\"text/plain\").status(500).send(\"Webhook Error - we attempted to validate this request without first configuring our auth token.\");\n      } else {\n        // Check that the request originated from Twilio\n        var valid = validateExpressRequest(request, options?.authToken, {\n          url: options?.url,\n          host: options?.host,\n          protocol: options?.protocol\n        });\n        if (valid) {\n          next();\n        } else {\n          return response.type(\"text/plain\").status(403).send(\"Twilio Request Validation Failed.\");\n        }\n      }\n    } else {\n      next();\n    }\n  };\n}\nexports.webhook = webhook;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","webhook","validateExpressRequest","validateIncomingRequest","validateRequestWithBody","validateBody","validateRequest","getExpectedBodyHash","getExpectedTwilioSignature","scmp","require","crypto_1","url_1","url_parse_1","buildUrlWithStandardPort","parsedUrl","url","port","protocol","username","password","host","pathname","query","hash","addPort","toString","removePort","set","toFormUrlEncodedParam","paramName","paramValue","Array","from","Set","sort","map","val","reduce","acc","authToken","params","indexOf","data","keys","key","default","createHmac","update","Buffer","digest","body","createHash","twilioHeader","urlObject","urlWithPort","urlWithoutPort","signatureWithPort","signatureWithoutPort","validSignatureWithPort","validSignatureWithoutPort","bodyHash","expectedHash","bodySHA256","request","opts","options","webhookUrl","headers","format","originalUrl","search","replace","header","rawBody","token","undefined","validate","tokenString","i","l","arguments","length","arg","assign","process","env","TWILIO_AUTH_TOKEN","hook","response","next","type","status","send","console","error","valid"],"sources":["/Users/sachin/Desktop/Assignment/cpf/node_modules/twilio/lib/webhooks/webhooks.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.webhook = exports.validateExpressRequest = exports.validateIncomingRequest = exports.validateRequestWithBody = exports.validateBody = exports.validateRequest = exports.getExpectedBodyHash = exports.getExpectedTwilioSignature = void 0;\nconst scmp = require(\"scmp\");\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst url_1 = __importDefault(require(\"url\"));\nconst url_parse_1 = __importDefault(require(\"url-parse\"));\n/**\n * Utility function to construct the URL string, since Node.js url library won't include standard port numbers\n *\n * @param parsedUrl - The parsed url object that Twilio requested on your server\n * @returns URL with standard port number included\n */\nfunction buildUrlWithStandardPort(parsedUrl) {\n    let url = \"\";\n    const port = parsedUrl.protocol === \"https:\" ? \":443\" : \":80\";\n    url += parsedUrl.protocol ? parsedUrl.protocol + \"//\" : \"\";\n    url += parsedUrl.username;\n    url += parsedUrl.password ? \":\" + parsedUrl.password : \"\";\n    url += parsedUrl.username || parsedUrl.password ? \"@\" : \"\";\n    url += parsedUrl.host ? parsedUrl.host + port : \"\";\n    url += parsedUrl.pathname + parsedUrl.query + parsedUrl.hash;\n    return url;\n}\n/**\n Utility function to add a port number to a URL\n\n @param parsedUrl - The parsed url object that Twilio requested on your server\n @returns URL with port\n */\nfunction addPort(parsedUrl) {\n    if (!parsedUrl.port) {\n        return buildUrlWithStandardPort(parsedUrl);\n    }\n    return parsedUrl.toString();\n}\n/**\n Utility function to remove a port number from a URL\n\n @param parsedUrl - The parsed url object that Twilio requested on your server\n @returns URL without port\n */\nfunction removePort(parsedUrl) {\n    parsedUrl.set(\"port\", \"\");\n    return parsedUrl.toString();\n}\n/**\n Utility function to convert request parameter to a string format\n\n @param paramName - The request parameter name\n @param paramValue - The request parameter value\n @returns Formatted parameter string\n */\nfunction toFormUrlEncodedParam(paramName, paramValue) {\n    if (paramValue instanceof Array) {\n        return Array.from(new Set(paramValue))\n            .sort()\n            .map((val) => toFormUrlEncodedParam(paramName, val))\n            .reduce((acc, val) => acc + val, \"\");\n    }\n    return paramName + paramValue;\n}\n/**\n Utility function to get the expected signature for a given request\n\n @param authToken - The auth token, as seen in the Twilio portal\n @param url - The full URL (with query string) you configured to handle\n this request\n @param params - the parameters sent with this request\n @returns signature\n */\nfunction getExpectedTwilioSignature(authToken, url, params) {\n    if (url.indexOf(\"bodySHA256\") !== -1 && params === null) {\n        params = {};\n    }\n    var data = Object.keys(params)\n        .sort()\n        .reduce((acc, key) => acc + toFormUrlEncodedParam(key, params[key]), url);\n    return crypto_1.default\n        .createHmac(\"sha1\", authToken)\n        .update(Buffer.from(data, \"utf-8\"))\n        .digest(\"base64\");\n}\nexports.getExpectedTwilioSignature = getExpectedTwilioSignature;\n/**\n Utility function to get the expected body hash for a given request's body\n\n @param body - The plain-text body of the request\n */\nfunction getExpectedBodyHash(body) {\n    return crypto_1.default\n        .createHash(\"sha256\")\n        .update(Buffer.from(body, \"utf-8\"))\n        .digest(\"hex\");\n}\nexports.getExpectedBodyHash = getExpectedBodyHash;\n/**\n Utility function to validate an incoming request is indeed from Twilio\n\n @param authToken - The auth token, as seen in the Twilio portal\n @param twilioHeader - The value of the X-Twilio-Signature header from the request\n @param url - The full URL (with query string) you configured to handle this request\n @param params - the parameters sent with this request\n @returns valid\n */\nfunction validateRequest(authToken, twilioHeader, url, params) {\n    twilioHeader = twilioHeader || \"\";\n    const urlObject = new url_parse_1.default(url);\n    const urlWithPort = addPort(urlObject);\n    const urlWithoutPort = removePort(urlObject);\n    /*\n     *  Check signature of the url with and without the port number\n     *  since signature generation on the back end is inconsistent\n     */\n    const signatureWithPort = getExpectedTwilioSignature(authToken, urlWithPort, params);\n    const signatureWithoutPort = getExpectedTwilioSignature(authToken, urlWithoutPort, params);\n    const validSignatureWithPort = scmp(Buffer.from(twilioHeader), Buffer.from(signatureWithPort));\n    const validSignatureWithoutPort = scmp(Buffer.from(twilioHeader), Buffer.from(signatureWithoutPort));\n    return validSignatureWithoutPort || validSignatureWithPort;\n}\nexports.validateRequest = validateRequest;\nfunction validateBody(body, bodyHash) {\n    var expectedHash = getExpectedBodyHash(body);\n    return scmp(Buffer.from(bodyHash), Buffer.from(expectedHash));\n}\nexports.validateBody = validateBody;\n/**\n Utility function to validate an incoming request is indeed from Twilio. This also validates\n the request body against the bodySHA256 post parameter.\n\n @param authToken - The auth token, as seen in the Twilio portal\n @param twilioHeader - The value of the X-Twilio-Signature header from the request\n @param url - The full URL (with query string) you configured to handle this request\n @param body - The body of the request\n @returns valid\n */\nfunction validateRequestWithBody(authToken, twilioHeader, url, body) {\n    const urlObject = new url_parse_1.default(url, true);\n    return (validateRequest(authToken, twilioHeader, url, {}) &&\n        validateBody(body, urlObject.query.bodySHA256 || \"\"));\n}\nexports.validateRequestWithBody = validateRequestWithBody;\n/**\n Utility function to validate an incoming request is indeed from Twilio.\n adapted from https://github.com/crabasa/twiliosig\n\n @param request - A request object (based on Express implementation http://expressjs.com/api.html#req.params)\n @param authToken - The auth token, as seen in the Twilio portal\n @param opts - options for request validation:\n    -> url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n    -> host: manually specify the host name used by Twilio in a number's webhook config\n    -> protocol: manually specify the protocol used by Twilio in a number's webhook config\n */\nfunction validateIncomingRequest(request, authToken, opts) {\n    var options = opts || {};\n    var webhookUrl;\n    if (options.url) {\n        // Let the user specify the full URL\n        webhookUrl = options.url;\n    }\n    else {\n        // Use configured host/protocol, or infer based on request\n        var protocol = options.protocol || request.protocol;\n        var host = options.host || request.headers.host;\n        webhookUrl = url_1.default.format({\n            protocol: protocol,\n            host: host,\n            pathname: request.originalUrl,\n        });\n        if (request.originalUrl.search(/\\?/) >= 0) {\n            webhookUrl = webhookUrl.replace(/%3F/g, \"?\");\n        }\n    }\n    if (webhookUrl.indexOf(\"bodySHA256\") > 0) {\n        return validateRequestWithBody(authToken, request.header(\"X-Twilio-Signature\") || \"\", webhookUrl, request.rawBody || \"{}\");\n    }\n    else {\n        return validateRequest(authToken, request.header(\"X-Twilio-Signature\") || \"\", webhookUrl, request.body || {});\n    }\n}\nexports.validateIncomingRequest = validateIncomingRequest;\nfunction validateExpressRequest(request, authToken, opts) {\n    return validateIncomingRequest(request, authToken, opts);\n}\nexports.validateExpressRequest = validateExpressRequest;\n/**\nExpress middleware to accompany a Twilio webhook. Provides Twilio\nrequest validation, and makes the response a little more friendly for our\nTwiML generator.  Request validation requires the express.urlencoded middleware\nto have been applied (e.g. app.use(express.urlencoded()); in your app config).\n\nOptions:\n- validate: {Boolean} whether or not the middleware should validate the request\n    came from Twilio.  Default true. If the request does not originate from\n    Twilio, we will return a text body and a 403.  If there is no configured\n    auth token and validate=true, this is an error condition, so we will return\n    a 500.\n- host: manually specify the host name used by Twilio in a number's webhook config\n- protocol: manually specify the protocol used by Twilio in a number's webhook config\n- url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n\nReturns a middleware function.\n\nExamples:\nvar webhookMiddleware = twilio.webhook();\nvar webhookMiddleware = twilio.webhook('asdha9dhjasd'); //init with auth token\nvar webhookMiddleware = twilio.webhook({\n    validate:false // don't attempt request validation\n});\nvar webhookMiddleware = twilio.webhook({\n    host: 'hook.twilio.com',\n    protocol: 'https'\n});\n */\nfunction webhook(opts, authToken) {\n    let token;\n    let options = undefined;\n    // Narrowing the args\n    if (opts) {\n        if (typeof opts === \"string\") {\n            token = opts;\n        }\n        if (typeof opts === \"object\") {\n            options = opts;\n        }\n    }\n    if (authToken) {\n        if (typeof authToken === \"string\") {\n            token = authToken;\n        }\n        if (typeof authToken === \"object\") {\n            options = authToken;\n        }\n    }\n    if (!options) {\n        options = {\n            validate: true,\n        };\n    }\n    // Process arguments\n    var tokenString;\n    for (var i = 0, l = arguments.length; i < l; i++) {\n        var arg = arguments[i];\n        if (typeof arg === \"string\") {\n            tokenString = arg;\n        }\n        else {\n            options = Object.assign(options || {}, arg);\n        }\n    }\n    // set auth token from input or environment variable\n    if (options) {\n        options.authToken = tokenString\n            ? tokenString\n            : process.env.TWILIO_AUTH_TOKEN;\n    }\n    // Create middleware function\n    return function hook(request, response, next) {\n        // Do validation if requested\n        if (options?.validate) {\n            // Check if the 'X-Twilio-Signature' header exists or not\n            if (!request.header(\"X-Twilio-Signature\")) {\n                return response\n                    .type(\"text/plain\")\n                    .status(400)\n                    .send(\"No signature header error - X-Twilio-Signature header does not exist, maybe this request is not coming from Twilio.\");\n            }\n            // Check for a valid auth token\n            if (!options?.authToken) {\n                console.error(\"[Twilio]: Error - Twilio auth token is required for webhook request validation.\");\n                response\n                    .type(\"text/plain\")\n                    .status(500)\n                    .send(\"Webhook Error - we attempted to validate this request without first configuring our auth token.\");\n            }\n            else {\n                // Check that the request originated from Twilio\n                var valid = validateExpressRequest(request, options?.authToken, {\n                    url: options?.url,\n                    host: options?.host,\n                    protocol: options?.protocol,\n                });\n                if (valid) {\n                    next();\n                }\n                else {\n                    return response\n                        .type(\"text/plain\")\n                        .status(403)\n                        .send(\"Twilio Request Validation Failed.\");\n                }\n            }\n        }\n        else {\n            next();\n        }\n    };\n}\nexports.webhook = webhook;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}